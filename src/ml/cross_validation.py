import numpy as np

from src.evaluation import CrossValidation
from data import MachineLearningData
from bayes_matrix import BayesMatrix
from utils import create_column_matrix, create_binary_matrix

NOT_NECESSARY = 1


class ConfusionMatrix():

    def __init__(self, predicted_results, real_results):
        self.predicted_results = predicted_results
        self.real_results = real_results

        self.tp = 0
        self.tn = 0
        self.fp = 0
        self.fn = 0

    def run(self):
        matrix_values = np.zeros(shape=(2, 2))
        num_classification = len(self.predicted_results)

        for i in range(num_classification):
            row = self.predicted_results[i][0]
            column = self.real_results[i][0]

            matrix_values[row][column] += 1

        self.tp = matrix_values[0][0]
        self.tn = matrix_values[1][1]
        self.fp = matrix_values[0][1]
        self.fn = matrix_values[1][0]


class Evaluation():

    '''
    :param predicted_results: The classifications generated by the machine
                              learning algorithm. This variable will be a
                              column matrix, where the number of lines
                              is equal to the number of data used to
                              validate the algorithm.

    :param real_results:      The real classifications of the data used to
                              test the machine learning algorithm. This
                              variable will be a column matrix, where the
                              number of lines  is equal to the number of
                              data used to validate the algorithm.

    :possible_classification: An list containg the labels that a input vector
                              can be classified upon.
    '''

    def __init__(self, predicted_results, real_results,
                 possible_classifications):
        self.predicted_results = predicted_results
        self.real_results = real_results
        self.possible_classifications = possible_classifications

    def create_confusion_matrix(self, classification):
        default_value = 0

        # Create binary classifications using the one received as parameter
        binary_predictions = create_binary_matrix(self.predicted_results,
                                                  classification,
                                                  default_value)
        binary_real = create_binary_matrix(self.real_results, classification,
                                           default_value)

        return ConfusionMatrix(binary_predictions, binary_real)


class CrossValidationMachineLearning(CrossValidation):

    def __init__(self, partition_proportion, rounds,
                 metrics_list, labels, thresholds):

        self.ml_data = MachineLearningData()
        self.labels = labels
        self.thresholds = thresholds

        super(CrossValidationMachineLearning,
              self).__init__(partition_proportion, rounds, None,
                             metrics_list, 0)

    def get_model(self, cross_item_score):
        '''
        This function should get the data that will be used as training data,
        train the algorithm with this data and return the generated model
        '''
        print 'get model'
        bayes_matrix = BayesMatrix()

        all_matrix = (np.matrix(cross_item_score.values()))
        data_matrix = all_matrix[0:, 0:-1]
        classifications = all_matrix[0:, -1]

        bayes_matrix.training(data_matrix, classifications,
                              self.labels)

        return bayes_matrix

    def get_user_score(self, user):
        print "User score"
        return self.ml_data.create_data(self.labels, self.thresholds)

    def get_predicted_results(self, round_user, round_partition, result_size):
        '''
        This method should generate the predictions for the packages
        received. It basically needs to used the generated model
        and use it to generate the prediction.
        '''
        # use the round_partition data on the model representes by round_user
        # return a column_vector that represents the predicted results for
        # round partition
        print 'predicted results'

        predicted_results = []

        for pkg, input_vector in round_partition.iteritems():
            input_vector = np.matrix(str(input_vector[:-1]))
            print input_vector.shape
            predicted_results.append(
                round_user.get_classification(input_vector))

        return create_column_matrix(predicted_results)

    def get_real_results(self, round_partition):
        '''
        This method should return the real labels for the validation
        set used on the algorithm.
        '''
        print 'real results'
        classifications = []

        for input_vector in round_partition.values():
            classifications.append(input_vector[-1])

        # make classifications a column array
        return create_column_matrix(classifications)

    def get_result_size(self):
        print 'result size'
        return NOT_NECESSARY

    def run_metrics(self, predicted_result, real_result):
        print 'run metrics'
        right = 0
        wrong = 0

        for index, result in enumerate(predicted_result):
            if result[0] == real_result[index, 0]:
                right += 1
            else:
                wrong += 1

        print "Right: {0}\nWrong: {1}\n\n".format(right, wrong)
